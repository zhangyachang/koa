# 调试相关

* [nodemon](#nodemon)
* [使用谷歌浏览器调试](#使用谷歌浏览器调试)
* [pm2](#pm2)





## nodemon

我们在改写代码后需要在终端中 `ctrl + c` 将程序结束，然后再次 `node 程序文件名入口.js` 继续启动，这样频繁的操作对我们来说浪费时间和精力，使用此模块启动后，就有类似于开发 web 中热更新的作用，他会自动的再次执行我们的程序。

```js
npm install -g nodemon // 安装

nodemon [your node app]
```

  



## 使用谷歌浏览器调试

```
1. node --inspect app.js
2. 打开chrome浏览器
```



详细的可以查看阮一峰 [Node 调试工具入门教程](http://www.ruanyifeng.com/blog/2018/03/node-debugger.html)





## pm2

由于 Node.js 是单线程的，我们开发的程序不可避免的会在代码执行过程中出错，然后将整个应用程序中断，所以我们需要在程序中断后再次启动，但是我们不可以一直守着服务器看到服务中断后自己再去重新执行程序。

> 果直接通过 node app 来启动，如果报错了可能直接停止导致整个服务崩溃；

```undefined
1. pm2 是开源的基于Nodejs的进程管理器，包括守护进程、监控、日志的一整套完整的功能；
2. pm2 基本是node应用程序不二的守护进程选择；
3. 事实上，pm2并不仅仅可以启动node程序，对于一般的脚本程序同样可以胜任；
4. pm2 带有负载均衡功能，可以保持node应用进程永远运行在后台；
5. pm2 还有个非常强大的deploy功能，可以从本地直接部署线上网站。
```



```js
pm2 start app.js --name mynode：启动node，并指定进程名称为mynode
pm2 list // 查看当前使用pm2启动的服务列表
pm2 logs // 查看日志
```



使用一个例子来看一下。







**跨域调试**

```js
app.use(async (ctx, next) => {
  // 加上去了 解决 cors 跨域问题
  ctx.set("Access-Control-Allow-Origin", "*");
  ctx.set("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With,aaa,ze_tk");
  ctx.set("Access-Control-Allow-Methods", "PUT,POST,GET,DELETE,OPTIONS");
  // ctx.set("Access-Control-Max-Age", 1728000); // 阻止非预检请求 20天
  // ctx.set("Access-Control-Expose-Headers", "Authorization"); // 如果想要浏览器响应其他内容 需要加上
  // ctx.set("Access-Control-Expose-Headers", "zaa"); // 如果想要浏览器响应其他内容 需要加上
  if(ctx.method == "OPTIONS") ctx.status = 200;
  else await next();
});
```

