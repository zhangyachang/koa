# 核心模块

* [event](#event (事件触发器))
* [path](#path模块)
* [url(URL)](#url(URL))
* [assert](#assert(断言))
* [crypto](#crypto (加密))
* [stream](#stream(流))
* [fs](#fs (文件系统))
* [http](#http模块)
* [Buffer](#Buffer)
* [网络编程](#网络编程)



## event (事件触发器)

> 大多数 Node.js 核心 API 构建于惯用的异步事件驱动架构，其中某些类型的对象（又称触发器，Emitter）会触发命名事件来调用函数（又称监听器，Listener）
>
> 例如，[`net.Server`](http://nodejs.cn/api/net.html#net_class_net_server) 会在每次有新连接时触发事件，[`fs.ReadStream`](http://nodejs.cn/api/fs.html#fs_class_fs_readstream) 会在打开文件时触发事件，[stream](http://nodejs.cn/api/stream.html)会在数据可读时触发事件。
>
> 所有能触发事件的对象都是 `EventEmitter` 类的实例。 这些对象有一个 `eventEmitter.on()` 函数，用于将一个或多个函数绑定到命名事件上。 事件的命名通常是驼峰式的字符串，但也可以使用任何有效的 JavaScript 属性键。。
>
> 当 `EventEmitter` 对象触发一个事件时，所有绑定在该事件上的函数都会被同步地调用。 被调用的监听器返回的任何值都将会被忽略并丢弃。



例子，一个简单的 `EventEmitter` 实例，绑定了一个监听器。 `eventEmitter.on()` 用于注册监听器， `eventEmitter.emit()` 用于触发事件。

```js
const EventEmitter = require('events');

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();
myEmitter.on('event', () => {
  console.log('触发事件');
});
myEmitter.emit('event');
```



使用 `eventEmitter.once()` 可以注册最多可调用一次的监听器。 当事件被触发时，监听器会被注销，然后再调用。

```js
const myEmitter = new MyEmitter();
let m = 0;
myEmitter.once('event', () => {
  console.log(++m);
});
myEmitter.emit('event');
// 打印: 1
myEmitter.emit('event');
// 不触发
```



**注意：** 事件触发器的实例化对象最多监听10个，如果监听超过10个会报错

```js
internal/process/warning.js:41 (node:14279) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. 11 event listeners added to [EventEmitter]. Use emitter.setMaxListeners() to increase limit
(Use `node --trace-warnings ...` to show where the warning was created)
```



```js
myEmitter.getMaxListeners(); // 10
```

可以通过 

```js
myEmitter.setMaxListeners(100); // 来设置可以监听的个数。
```





## path模块

>`path` 模块提供了一些实用工具，用于处理文件和目录的路径。 可以使用以下方式访问它：

```js
const path = require('path');
```



>`path` 模块的默认操作会因 Node.js 应用程序运行所在的操作系统而异。 具体来说，当在 Windows 操作系统上运行时， `path` 模块会假定正被使用的是 Windows 风格的路径。

> 因此，使用 `path.basename()` 可能会在 POSIX 和 Windows 上产生不同的结果

> 如果要在任意操作系统上使用 Windows 文件路径时获得一致的结果，则使用 [`path.win32`](http://nodejs.cn/api/path.html#path_path_win32)：



**Path.join**

> `path.join()` 方法会将所有给定的 `path` 片段连接到一起（使用平台特定的分隔符作为定界符），然后规范化生成的路径。
>
> 长度为零的 `path` 片段会被忽略。 如果连接后的路径字符串为长度为零的字符串，则返回 `'.'`，表示当前工作目录。

```js
path.join('/目录1', '目录2', '目录3/目录4', '目录5', '..');
// 返回: '/目录1/目录2/目录3/目录4'

path.join('目录1', {}, '目录2');
// 抛出 'TypeError: Path must be a string. Received {}'
```



```js
__dirname 
// 返回: '/Users/saien/'

path.join(__dirname, "..", "a") 
// 返回： '/Users/a'

path.join(__dirname, "a", "b");
// 返回： '/Users/saien/a/b'


在windows电脑上盘符是右划线  '\Users\saien\a\b'
```



**Path.parse**

> `path.parse()` 方法会返回一个对象，其属性表示 `path` 的有效元素。 尾部的目录分隔符会被忽略



```js
path.parse(__filename)

返回
{
  root: '/',
  dir: '/Users/saien/devProject/share/koa/demo/小案例/04path',
  base: 'main.js',
  ext: '.js',
  name: 'main'
}
```



**Path.format**

> `path.format()` 方法从对象返回路径字符串。 与 [`path.parse()`](http://nodejs.cn/api/path.html#path_path_parse_path) 相反。

```js
const file = {
  root: "/",
  dir: "/Users/saien/devProject/share/koa/demo/小案例/04path",
  base: "main.js",
  ext: ".js",
  name: "main",
};

path.format(file);
// 返回：/Users/saien/devProject/share/koa/demo/小案例/04path/main.js
```





## url(URL)

> `url` 模块用于处理与解析 URL。 使用方法如下：

```js
const url = require('url');
```





## assert(断言)





## crypto (加密)

> `crypto` 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。

```js
const crypto = require('crypto');

function createMd5(str) {
  return crypto.createHash("md5").update(str).digest("hex");
}
createMd5("hello world!!");
// 570599d420acc25723b337b0db95c7c7
```



```js
const crypto = require('crypto');

const secret = 'abcdefg';
const hash = crypto.createHmac('sha256', secret)
                   .update('I love cupcakes')
                   .digest('hex');
console.log(hash);
// 打印:
//   c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e
```







## stream(流)

https://www.cnblogs.com/tugenhua0707/p/10821768.html



流式读取一个文件的信息

```js
const fs = require('fs');
let read = fs.createReadStream('./1.txt');

read.setEncoding('utf8'); /* 这个东西要设置上，如果不设置上默认的是 toString() */

read.on('data',()=>{
    console.log('1');
});
read.on('end',()=>{
    console.log('读取结束');
});
```





把一个文件的内容写入到另外一个文件内

```js
const fs = require('fs');
const read = fs.createReadStream('./1.txt');
const write = fs.createWriteStream('./2.txt');
read.pipe(write);
```



read.resume

```js
read.resume();  //让流从停止状态变为流动状态
```



**原生stream**

```js
const Readable = require('stream').Readable;
const fs = require('fs');
const rs = new Readable();

const write = fs.createWriteStream('./3.txt');


rs.push('1');
rs.push('2');
rs.push(null);  // 关门 不能再push了 如果在也不push之后了就

// rs.pipe(process.stdout);

rs.pipe(write);

// rs.on('data',(chuck)=>{
//     console.log(chuck);
// });


```





## fs (文件系统)

> `fs` 模块使能够以一种模仿标准 POSIX 函数的方式与文件系统进行交互。

用来操作文件的

​	方法有2个，后面都可以加上后缀名 `Sync` 代表的是同步操作



要使用此模块：

```js
const fs = require('fs');
```

所有的文件系统操作都具有同步的、回调的、以及基于 promise 的形式。





**同步的示例**

> 同步的形式阻塞 Node.js 事件循环和进一步的 JavaScript 执行，直到操作是完成的。 异常是被立即地抛出，且可以被使用 `try…catch` 处理，或者可以被允许冒泡。

```js
const fs = require('fs');

try {
  fs.unlinkSync('/tmp/hello');
  console.log('/tmp/hello 已被成功地删除');
} catch (err) {
  // 处理错误

```



**回调的示例**

> 回调的形式把一个完成回调函数作为其最后一个参数，并且异步地调用该操作。 被传给完成回调的参数取决于方法，但是第一个参数总是被预留给一个异常。 如果操作被成功地完成，则第一个参数是 `null` 或 `undefined`。

```js
const fs = require('fs');

fs.unlink('/tmp/hello', (err) => {
  if (err) throw err;
  console.log('/tmp/hello 已被成功地删除');
});
```



**Promise 的示例**

> 基于 promise 的操作返回一个当异步的操作是完成的时被解决的 `Promise`。

```js
const fs = require('fs/promises');

(async function(path) {
  try {
    await fs.unlink(path);
    console.log(`${path} 已被成功地删除`);
  } catch (error) {
    console.error('有一个错误：', error.message);
  }
})('/tmp/hello');
```





**appendFile**

> 异步地追加数据到文件，如果文件尚不存在则创建文件。 `data` 可以是字符串或 [`Buffer`](http://nodejs.cn/api/buffer.html#buffer_buffer)。

```js
fs.appendFile('文件.txt', '追加的数据', (err) => {
  if (err) throw err;
  console.log('数据已被追加到文件');
});
```





`fs.mkdir` 创建文件夹

`fs.open` 异步的打开文件

`fs.opendir` 异步的打开文件目录

`fs.readFile` 异步地读取文件的全部内容

`rmdir`  删除文件夹

`unlik`  删除文件

`writeFile`  写入 (替换文件的内容)

`readdir` 读取文件夹信息

`rename` 重命名

.... 





## http模块

```js
const http = require('http')
const fs = require('fs')

const server = http.createServer(function(req, res) {
  fs.readFile(__dirname + '/data.txt', (err, data) => {
    res.end(data)
  })
})
server.listen(3000)
```

`readFile()` 读取文件的全部内容，并在完成时调用回调函数。

回调中的 `res.end(data)` 会返回文件的内容给 HTTP 客户端。

如果文件很大，则该操作会花费较多的时间。 以下是使用流编写的相同内容：



```js
const http = require('http')
const fs = require('fs')

const server = http.createServer((req, res) => {
  const stream = fs.createReadStream(__dirname + '/data.txt')
  stream.pipe(res)
})
server.listen(3000)
```



**发起一个http请求**

```js
var options = { 
 hostname: '127.0.0.1', 
 port: 1334, 
 path: '/', 
 method: 'GET' 
}; 
var req = http.request(options, function(res) { 
 console.log('STATUS: ' + res.statusCode); 
 console.log('HEADERS: ' + JSON.stringify(res.headers)); 
 res.setEncoding('utf8'); 
 res.on('data', function (chunk) { 
 console.log(chunk); 
 }); 
}); 
req.end();
```







## Buffer

> js对于字符串 (string) 的操作十分友好，无论是宽字节字符串还是单字节字符串，都被认为是一个字符串。



> 文件和网络 I/O对于前端而言都是不曾有的应用场景。但是在Node中，应用需要处理网络协议、操作数据库、处理图片、接收上传文件等，在网络流和文件的操作中，还要处理大量的二进制数据，JavaScript自有的字符串远远不能满足这些需求，于是Buffer对象应运而生。



由于 `Buffer` 太过常见，Node在进程启动时就已经加载了它，并将其放在全局对象 (global) 上。所以在使用 `Buffer` 时，无须通过 `require` 即可直接使用。



**字符串转 Buffer**

```js
Buffer.from("要转的字符串", [encoding])
```



**Buffer转字符串**

```js
buf.toString([encoding], [start], [end]);
```



**Buffer的拼接**

> Buffer 在使用场景中，通常是以一段一段的方式传输。以下是常见的从输入流中读取内容的示例代码

```js
const fs = require("fs");

const rs = fs.createReadStream("./public/1.txt");

let data = "";
rs.on("data", function (chunk) {
  console.log("流data触发");
  data += chunk;
});

rs.on("end", function () {
  console.log("end", data);
});
```

> 上面这段代码常见于国外，用于流读取的示范，data事件中获取chunk对象即是 Buffer 对象。对于初学者而言，容易将 Buffer 当做字符串来理解，所以在接受上面的示例时不会觉得有任何异常。
>
> 一旦输入流中有宽字节编码时，问题就会暴露出来。如果你在通过 Node 开发的网站上看到 乱码符号，那么该问题多半来自这里

```js 
data += chunk;

// 这句代码里隐藏了 toString() 操作，它等价于如下的代码。

data = data.toString() + chunk.toString()
```

> 值得注意的是，外国人的语境通常是指英文环境，在他们的场景下，这个 toString() 不会造成任何问题。但对于宽字节的中文，确会形成问题。为了重现这个问题，下面我们模拟近似的场景，将文件可读流的每次读取的 Buffer 长度限制为 11，代码如下

```js
const rs = fs.createReadStream("./public/1.txt", { highWaterMark: 11 });

<Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c>,
<Buffer 88 e5 85 89 ef bc 8c e7 96 91 e6>,
<Buffer 98 af e5 9c b0 e4 b8 8a e9 9c 9c>,
<Buffer e3 80 82 e4 b8 be e5 a4 b4 e6 9c>,
<Buffer 9b e6 98 8e e6 9c 88 ef bc 8c e4>,
<Buffer bd 8e e5 a4 b4 e6 80 9d e6 95 85>,
<Buffer e4 b9 a1 e3 80 82>

床前明��光，疑���地上霜。举头��明月，���头思故乡。
```

> 上文提到的 buf.toString() 方法默认是以 UTF-8 为编码，中文字在 UTF-8 下占 3 个字节。所以第一个 Buffer 对象在输出的时候，只能显示 3 个字符，Buffer 中剩下的 2 个字节 (6c 9c)将会以乱码的形式显示。第二个 Buffer 对象的第一个字节也不能形成文字，只能以乱码显示。于是形成一些文字无法正常显示的问题。
>
> 在这个示例中我们构造了11这个限制，但是对于任意长度的Buffer而言，宽字节字符串都有可能存在被截断的情况，只不过 Buffer 的长度越大出现的概率越低而已，但该问题依然不可忽视。





**Buffer的性能**

> Buffer在文件 I/O 和网络 I/O 中运用广泛，尤其在网络传输中，它的性能举足轻重。在应用中，我们通常会操作字符串，但一旦在网络中传输，都需要转换为 Buffer，以二进制数据传输。
>
> 在Web应用中，字符串转到Buffer是时时刻刻发生的，提高字符串到Buffer的转换效率，可以很大程度的提高网络吞吐率。





## 网络编程

> Node提供了 net、dgram、http、https这四个模块，分别用于处理 TCP、UDP、HTTP、HTTPS，适用于服务器端和客户端。



同样的https的模块

```js
tls

https
```

