# 基础知识

* [`[Basic]` 模块的导入导出](#模块的导入导出)
* [`[Basic]` 顶层对象](#顶层对象)
* [`[Basic]` 模块封装器](#模块封装器)
  [浏览器与Node的事件循环(Event Loop)有何区别?](https://zhuanlan.zhihu.com/p/54882306)



## 模块的导入导出

> 在 Node.js 模块系统中，每个文件都被视为一个独立的模块。



**导出方法一**

`a.js`

```js
const b = require("./b");

// { name: '张三', a: 111 }
```



`b.js`

```js
module.exports = {
  name: "张三",
  a: 111,
};
```



**导出方法二**

> `exports` 变量是在模块的文件级作用域内可用的，且在模块执行之前赋值给 `module.exports`。
>
> 它允许使用快捷方式，因此 `module.exports.f = ...` 可以更简洁地写成 `exports.f = ...`。 但是，就像任何变量一样，如果为 `exports` 赋予了新值，则它将不再绑定到 `module.exports`：

`b.js`

```js
exports.name = "张三";
exports.a = 111;
```



```js
module.exports.hello = true; // 从模块的引用中导出。

exports = { hello: false };  // 不导出，仅在模块中可用。
```



**注意：** `exports` 实际上是 `module.exports`的引用，所以如果尝试给 `exports` 重新赋值是无法导出内容的

`a.js`

```js
const b = require("./b");
b
// {}
```

` b.js`

```js
exports = {
  a: 1,
  b: 2,
};
```



**注意：** 对 `module.exports` 的赋值必须立即完成。 不能在任何回调中完成。 以下是不起作用的：

```js
setTimeout(() => {
  module.exports = { a: 'hello' };
}, 0);
```



**缓存**

>模块在第一次加载后会被缓存。 这也意味着（类似其他缓存机制）如果每次调用 `require('foo')` 都解析到同一文件，则返回相同的对象。
>
>多次调用 `require(foo)` 不会导致模块的代码被执行多次。 这是一个重要的特性。 借助它, 可以返回“部分完成”的对象，从而允许加载依赖的依赖, 即使它们会导致循环依赖。
>
>如果想要多次执行一个模块，可以导出一个函数，然后调用该函数。



**循环引用**

`a.js`

```js
console.log('a 开始');
exports.done = false;
const b = require('./b.js');
console.log('在 a 中，b.done = %j', b.done);
exports.done = true;
console.log('a 结束');
```

`b.js`

```js
console.log('b 开始');
exports.done = false;
const a = require('./a.js');
console.log('在 b 中，a.done = %j', a.done);
exports.done = true;
console.log('b 结束');
```

`main.js`

```js
console.log('main 开始');
const a = require('./a.js');
const b = require('./b.js');
console.log('在 main 中，a.done=%j，b.done=%j', a.done, b.done);
```



当 `main.js` 加载 `a.js` 时， `a.js` 又加载 `b.js`。 此时， `b.js` 会尝试去加载 `a.js`。 为了防止无限的循环，会返回一个 `a.js` 的 `exports` 对象的 **未完成的副本** 给 `b.js` 模块。 然后 `b.js` 完成加载，并将 `exports` 对象提供给 `a.js` 模块。

当 `main.js` 加载这两个模块时，它们都已经完成加载。 因此，该程序的输出会是：

```js
$ node main.js
main 开始
a 开始
b 开始
在 b 中，a.done = false
b 结束
在 a 中，b.done = true
a 结束
在 main 中，a.done=true，b.done=true
```





## 顶层对象

```js
global

在浏览器中是window，在Node中是global
```





## 模块封装器

在执行模块代码之前，Node.js 会使用一个如下的函数封装器将其封装：

```js
(function(exports, require, module, __filename, __dirname) {
	// 模块的代码实际上在这里
});
```

通过这样做，Node.js 实现了以下几点：

- 它保持了顶层的变量（用 `var`、 `const` 或 `let` 定义）作用在模块范围内，而不是全局对象。
- 它有助于提供一些看似全局的但实际上是模块特定的变量，例如：
  - 实现者可以用于从模块中导出值的 `module` 和 `exports` 对象。
  - 包含模块绝对文件名和目录路径的快捷变量 `__filename` 和 `__dirname` 。



```js
__dirname // 当前模块的目录名。 相当于 __filename 的 path.dirname()。

__filename // 当前模块的文件名。 这是当前的模块文件的绝对路径（符号链接会被解析）。
```
